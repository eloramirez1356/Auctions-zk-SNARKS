pragma solidity >=0.4.22 < 0.6.0;
import "./verifier.sol";

contract Auction{
    //Instance of the Smart Contract generated by ZoKrates
    Verifier public verifierContractZoKrates;

    //Variables which indicates the bidding period
    uint public auctionStartingDate;
    uint public auctionEndingDate;

    //Variables which indicates the proving bids period
    uint public provingBidsStartingDate;
    uint public provingBidsEndingDate;
    
    uint public signalForBid; //Signal for bidding, used as minBid too
    uint public idAuction; //Auction Id
    uint public numberOfBidders; //Fixed number of bidders
    address payable public beneficiary; //Beneficiary Address
    address public auctioneer; //Auctioneer Address
    address public winner; //Winner Address
    bool public auctionEnded; //Variable which indicates the end of the auction
    bool public winnerObtained;

    
    //Array que contiene las apuestas + salts
    mapping(bytes32 => address payable) bidsAddresses; //Maping used for obtaining the address from the encrypted bids
    bytes32[] public bids; //Array which contains the three elements needed for the bid, concretely the encrypted bid with the public key and the ZoKrates Hashes
    bytes32[] public bidAmounts; //Clear encrypted bids, without hash
    bytes32[2][] public hashZokratesBids; //Clear hashed bids with ZoKrates Hash
    uint public biggestBid; //Variable for storing the biggest bid
    uint public positionWinnerBid; //Variable for Storing the position of the winner in the bid array
    bool public expectedHashes;



    constructor(uint _auctionStartingDate, uint _auctionEndingDate, uint _signalForBid,uint _idAuction, uint _numberOfBidders, address payable _beneficiary, address payable _auctioneer,address payable _verifierContractAddress) public {
        //All these variables are determined in the deployemnt of the Smart Conctract with Truffle
        auctionStartingDate = _auctionStartingDate;
        auctionEndingDate = _auctionEndingDate;
        provingBidsStartingDate = _auctionStartingDate + 200;
        provingBidsEndingDate = _auctionEndingDate + 200;
        signalForBid = _signalForBid * 1e18;
        idAuction = _idAuction;
        beneficiary = _beneficiary;
        auctioneer = _auctioneer;
        numberOfBidders = _numberOfBidders;
        verifierContractZoKrates = Verifier(_verifierContractAddress);
    }

    //Realizacion de la puja en el intervalo de la subasta
    //Tiene que poner que solo un usuario, que todos los valores de los hashes sean diferentes
    //En el javascript se pueden concatenar facilmente los numeros de Zokrates, y se mete como hashedEncryptedBid, donde se introducen juntos (out1, out2), y ademÃ¡s un salt
    //OJO, para comprobar la minima apuesta, hacerlo con el javascript porque en este caso no interesa meter el valor a pelo.
    //Poner la restriccion de numero de bidders

    //Function for bidding during the bidding period
    function bid(bytes32 hashedEncryptedBid) public payable{
        require(msg.sender != auctioneer, "Auctioneer cant bid");
        //require(now >= auctionStartingDate && now <= auctionEndingDate, "You only can bid during the bidding period");
        require(msg.value==signalForBid, "You have to pay signal for bidding");
        require(bidAmounts.length < numberOfBidders + 1, "All the possible bids has been done, no more bids can be done");
        bids.push(hashedEncryptedBid);
    }
    
    //Function for encrypting the values sent by bidders during the bidding period. This function is used in the bidProver function.
    function keccak256Hash(bytes32 encrypted, bytes32 hashZokrates1, bytes32 hashZokrates2) public pure returns (bytes32 hashSolidity){
        return keccak256(abi.encode(encrypted, hashZokrates1, hashZokrates2));
    }

    //Funcion que compara el hash inicial que contiene la apuesta encriptada con la clave publica y los hashes emitidos con zokrates
    function bidProver(bytes32 bidHashedSent, bytes32 encryptedBid, bytes32 hashZokrates1, bytes32 hashZokrates2) public payable{
        //Tengo que meterle la restriccion del segundo periodo, despues de que no se permitan mas pujas
        //require(now >= provingBidsStartingDate && now <= provingBidsStartingDate, "You only can prove that you have bid during the proving period, after bidding period");
        require(bidAmounts.length < numberOfBidders + 1, "All the bids have been proved");
        
        for (uint i = 0; i<bids.length; i++) {
            if (bids[i] == bidHashedSent) {
                require(bidHashedSent == keccak256Hash(encryptedBid, hashZokrates1, hashZokrates2), "The hashed bid sent does not correspond to hash of the values you are providing");
                //Filling the array with the encrypted values with the public key
                bidAmounts.push(encryptedBid);
                //Filling the array with the hashed values with the hash of ZoKrates
                hashZokratesBids.push([hashZokrates1, hashZokrates2]);
                //Mapping the addresses with the encrypted bids
                bidsAddresses[encryptedBid] = msg.sender;
                //Deleting bids from the bids array, to avoid cheating and bidding again by the same bidder
                delete bids[i];
                break;
            }
        }  
    }
    
    function checkingAuctioneerHashesInputs(uint hash0_0, uint hash0_1, uint hash1_0, uint hash1_1, uint hash2_0, uint hash2_1, uint hash3_0, uint hash3_1) public payable returns (bool correctHashes){
        uint[2][4] memory hashes = [[hash0_0, hash0_1], [hash1_0, hash1_1], [hash2_0, hash2_1], [hash3_0, hash3_1]];
        bool sameHashes;
        for(uint row = 0; row<hashZokratesBids.length; row++){
            if (!(((keccak256(abi.encodePacked(uint(hashZokratesBids[row][0])))) == (keccak256(abi.encodePacked((uint(hashes[row][0])))))) && ((keccak256(abi.encodePacked((uint(hashZokratesBids[row][1]))))) == (keccak256(abi.encodePacked(uint(hashes[row][1]))))))){
                return false;
            }
            if(row == 3){
                sameHashes = true;
            }
        }
        expectedHashes = sameHashes;
        return sameHashes;

    }

    //Function for submmiting the proof generated by ZoKrates, which states the winner in case that the proof was verified.
    event resultWinnerAndPosition(uint256 winnerEvent, uint256 positionEvent);
    function auctionEnd(uint[2] memory a,
            uint[2][2] memory b,
            uint[2] memory c,
            uint[14] memory input) public payable returns (uint position, uint highestBid){
        require(msg.sender == auctioneer, "Only the Auctioneer can determine the Winner of the bid");
        //require(now >= provingBidsEndingDate, "The auction has not ended");
        require(auctionEnded == false, "The auction has ended");
        //bool expectedHashes = checkingAuctioneerHashesInputs();
        bool correctHashesUsedByAuctioneer = checkingAuctioneerHashesInputs(input[0], input[1], input[2], input[3], input[4], input[5], input[6], input[7]);
        require(correctHashesUsedByAuctioneer, "The inputs regarding to the ZoKrates hashes are wrong, put them correctly in order in the array");
        //Checking if the proof sent by the auctioneer is correct or not
        bool result = verifierContractZoKrates.verifyTx(a, b, c, input);
        require(result == true, "Incorrect proof");
        emit resultWinnerAndPosition(input[13], input[12]);
        biggestBid = input[13] * 1e18;
        positionWinnerBid = input[12];
        winner = bidsAddresses[getBidAmounts(positionWinnerBid)];
        //Looping all the accounts for returning the Signal bid
        for (uint i = 0; i < bidAmounts.length; i++){
            bidsAddresses[getBidAmounts(i)].transfer(signalForBid);
        }
        winnerObtained = true;
        return (input[12], input[13]);
    }

    //Esta operacion solo puede ejecutarla el winner
    function paymentOperations() public payable{
        require(auctionEnded == false, "The auction has already ended and the profits are being sent");
        require(winnerObtained == true, "The winner has not been obtained yet");
        require(msg.sender == winner, "You are trying to call this function but you are not the winner");
        require(msg.value == biggestBid, "You have to pay the bid you promised for obtaining your profits");
        //Payment to the beneficiary
        beneficiary.transfer(msg.value);
        auctionEnded = true;

    }

    function getBids(uint i) public returns(bytes32 position){
        return bids[i];
    }

    function getBidAmounts(uint i) public returns(bytes32 encryptedAmount){
        return bidAmounts[i];
    }

    function getHashesZokrates(uint i) public returns(bytes32 hashZok1, bytes32 hashZok2){
        return (hashZokratesBids[i][0], hashZokratesBids[i][1]);
    }

    function setHashesZokrates(bytes32 a, bytes32 b) public {
        hashZokratesBids.push([a,b]);
    }
    
    function getBiggestBid() public returns (uint){
        return biggestBid;
    }

    function getWinner() public returns (address){
        return winner;
    }

    function setExpectedHashes(bool isCorrect) public {
        expectedHashes = isCorrect;
    }

}